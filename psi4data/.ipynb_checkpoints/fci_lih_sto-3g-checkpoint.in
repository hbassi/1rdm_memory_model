memory 10 gb

molecule lih {
H  0.       0.      -0.765
Li 0.       0.       0.765
symmetry c1
no_com
no_reorient
}

set {
    reference rhf
    basis sto-3g
    ms0 false
    fci true
    diag_method rsp
    num_roots 225
    num_dets_print 225
    print 2
    dipmom true
    opdm true
    tdm true
}

thisenergy, ciwfn = prop('detci', properties=['DIPOLE', 'TRANSITION_DIPOLE'], return_wfn=True)

mints = MintsHelper(ciwfn.basisset())

AOdip = mints.ao_dipole()
AOdip[0].print_out()
AOdip[1].print_out()
AOdip[2].print_out()

# MO coefficients
C = ciwfn.Ca().to_array()

# overlap matrix
S = ciwfn.S().to_array()

print("Overlap test:")
n = S.shape[0]
print(np.mean(np.abs(C.T @ S @ C - np.eye(n))))

# z-direction AO dipole moment matrix
AOdipmat = AOdip[2].to_array()
MOdipmat = C.T @ AOdipmat @ C

# set CI size
cisize = 225

# initialize CI dipole moment matrix in z direction
CIdimatzMO = np.zeros((cisize,cisize))
CIdimatzAO = np.zeros((cisize,cisize))
# initialize B tensor
Bten = np.zeros((cisize, cisize, n, n))
for i in range(cisize):
    for j in range(cisize):
        ciop_dm = ciwfn.get_opdm(i,j,'SUM',True)
        # store this in Bten
        Bten[i,j,:,:] = ciop_dm.to_array()
        # density matrix: change basis from MO to AO
        dmAO = C @ ciop_dm.to_array() @ C.T
        # compute this particular density matrix element
        CIdimatzMO[i, j] = np.trace( ciop_dm.to_array() @ MOdipmat )
        CIdimatzAO[i, j] = np.trace( dmAO @ AOdipmat )

print("Difference between CI basis dipole moment matrices computed via AO vs MO:")
print(np.mean(np.abs(CIdimatzMO - CIdimatzAO)))

# reshape OPDMs into B tensor

np.savez('./fci_lih_sto-3g.npz',C=C,S=S,AOdipmat=AOdipmat,CIdimatz=CIdimatzMO,Bten=Bten)

# for debugging purposes:
# Bmat = Bten.reshape((cisize**2, n**2))
# Bmat[np.abs(Bmat) < 1e-14] = 0.0
# print(Bmat)